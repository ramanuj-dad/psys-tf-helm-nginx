name: Deploy NGINX Ingress Controller

on:
  workflow_dispatch:
    inputs:
      action:
        description: 'Action to perform'
        required: true
        default: 'apply'
        type: choice
        options:
          - apply
          - destroy
  push:
    branches:
      - main
    paths:
      - 'terraform/**'
      - 'helm/**'
      - 'docker/**'
      - 'k8s/**'

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}/nginx-ingress-deployer

jobs:
  validate:
    name: Validate Configuration
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TERRAFORM_VERSION }}

      - name: Terraform Format Check
        working-directory: ./terraform
        run: terraform fmt -check -recursive

      - name: Terraform Init
        working-directory: ./terraform
        run: terraform init -backend=false

      - name: Terraform Validate
        working-directory: ./terraform
        run: terraform validate

      - name: Validate Helm Chart Values
        run: |
          helm repo add ingress-nginx https://kubernetes.github.io/ingress-nginx
          helm repo update
          helm template test-release ingress-nginx/ingress-nginx \
            --values ./helm/values.yaml \
            --dry-run > /dev/null
          echo "âœ… Helm values validation passed"

      - name: Validate Kubernetes manifests
        run: |
          kubectl --dry-run=client apply -f k8s/deployment-job.yaml

  build:
    name: Build Deployment Container
    runs-on: ubuntu-latest
    needs: validate
    outputs:
      image-digest: ${{ steps.build.outputs.digest }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Build container image
        id: build
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./docker/Dockerfile
          tags: ${{ env.IMAGE_NAME }}:${{ env.IMAGE_TAG }}
          outputs: type=docker,dest=/tmp/${{ env.IMAGE_NAME }}.tar
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: Upload image artifact
        uses: actions/upload-artifact@v4
        with:
          name: container-image
          path: /tmp/${{ env.IMAGE_NAME }}.tar
          retention-days: 1

  deploy:
    name: Deploy via Kubernetes Job
    runs-on: ubuntu-latest
    needs: [validate, build]
    if: github.event_name == 'workflow_dispatch' || (github.event_name == 'push' && github.ref == 'refs/heads/main')
    environment: ${{ github.event.inputs.environment || 'production' }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Download image artifact
        uses: actions/download-artifact@v4
        with:
          name: container-image
          path: /tmp

      - name: Configure SSH
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.SSH_PRIVATE_KEY }}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          echo "${{ secrets.SSH_KNOWN_HOSTS }}" > ~/.ssh/known_hosts
          chmod 600 ~/.ssh/known_hosts

      - name: Test SSH Connection
        run: |
          ssh -o StrictHostKeyChecking=no -i ~/.ssh/id_rsa ${{ secrets.TARGET_USER }}@${{ secrets.TARGET_HOST }} "echo 'SSH connection successful'"

      - name: Transfer Image to Remote
        run: |
          # Transfer the container image
          scp -i ~/.ssh/id_rsa /tmp/${{ env.IMAGE_NAME }}.tar ${{ secrets.TARGET_USER }}@${{ secrets.TARGET_HOST }}:/tmp/
          
          # Transfer project files
          ssh -i ~/.ssh/id_rsa ${{ secrets.TARGET_USER }}@${{ secrets.TARGET_HOST }} "mkdir -p ~/k8s-deployment"
          scp -i ~/.ssh/id_rsa -r ./terraform ./helm ./k8s ./scripts ${{ secrets.TARGET_USER }}@${{ secrets.TARGET_HOST }}:~/k8s-deployment/

      - name: Load Container Image
        run: |
          ssh -i ~/.ssh/id_rsa ${{ secrets.TARGET_USER }}@${{ secrets.TARGET_HOST }} '
            # Load the Docker image into containerd
            sudo ctr -n k8s.io images import /tmp/${{ env.IMAGE_NAME }}.tar
            
            # Verify image is loaded
            sudo ctr -n k8s.io images list | grep ${{ env.IMAGE_NAME }} || echo "Image not found in containerd"
            
            # Clean up tar file
            rm -f /tmp/${{ env.IMAGE_NAME }}.tar
          '

      - name: Setup Kubeconfig
        run: |
          ssh -i ~/.ssh/id_rsa ${{ secrets.TARGET_USER }}@${{ secrets.TARGET_HOST }} '
            # Ensure kubeconfig is properly set up
            mkdir -p ~/.kube
            sudo cp -i /etc/kubernetes/admin.conf ~/.kube/config
            sudo chown $(id -u):$(id -g) ~/.kube/config
            
            # Test kubectl access
            kubectl get nodes
          '

      - name: Deploy via Kubernetes Job
        env:
          CLUSTER_IP: ${{ secrets.TARGET_HOST }}
        run: |
          ACTION="${{ github.event.inputs.action || 'apply' }}"
          ssh -i ~/.ssh/id_rsa ${{ secrets.TARGET_USER }}@${{ secrets.TARGET_HOST }} "
            cd ~/k8s-deployment
            chmod +x scripts/*.sh
            export TF_VAR_cluster_ip=${CLUSTER_IP}
            ./scripts/deploy.sh ${ACTION}
          "

      - name: Get Deployment Logs
        if: always()
        run: |
          ACTION="${{ github.event.inputs.action || 'apply' }}"
          ssh -i ~/.ssh/id_rsa ${{ secrets.TARGET_USER }}@${{ secrets.TARGET_HOST }} "
            echo '=== Deployment Job Logs ==='
            kubectl logs job/nginx-ingress-deployment-${ACTION} -n deployment-automation --tail=100 || echo 'No logs available'
            
            echo ''
            echo '=== Job Status ==='
            kubectl get jobs -n deployment-automation || echo 'No jobs found'
            
            if [ '${ACTION}' = 'apply' ]; then
              echo ''
              echo '=== NGINX Ingress Status ==='
              kubectl get pods -n ingress-nginx || echo 'No ingress pods found'
              kubectl get svc -n ingress-nginx || echo 'No ingress services found'
            fi
          "

  test:
    name: Test Deployment
    runs-on: ubuntu-latest
    needs: deploy
    if: (github.event.inputs.action == 'apply' || (github.event_name == 'push' && github.ref == 'refs/heads/main')) && needs.deploy.result == 'success'
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure SSH
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.SSH_PRIVATE_KEY }}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          echo "${{ secrets.SSH_KNOWN_HOSTS }}" > ~/.ssh/known_hosts
          chmod 600 ~/.ssh/known_hosts

      - name: Run Test Job
        run: |
          ssh -i ~/.ssh/id_rsa ${{ secrets.TARGET_USER }}@${{ secrets.TARGET_HOST }} '
            cd ~/k8s-deployment
            ./scripts/deploy.sh test
          '

      - name: Deploy Sample Application
        run: |
          ssh -i ~/.ssh/id_rsa ${{ secrets.TARGET_USER }}@${{ secrets.TARGET_HOST }} '
            echo "Deploying sample application..."
            kubectl apply -f ~/k8s-deployment/examples/sample-app.yaml
            
            # Wait for sample app
            kubectl wait --namespace sample-app \
              --for=condition=ready pod \
              --selector=app=sample-web-app \
              --timeout=120s
            
            echo "Sample application deployed successfully!"
            echo "Test access with: curl -H \"Host: demo.local\" http://${{ secrets.TARGET_HOST }}/"
          '

  cleanup:
    name: Cleanup Jobs
    runs-on: ubuntu-latest
    needs: [deploy, test]
    if: always() && (needs.deploy.result == 'success' || needs.deploy.result == 'failure')
    
    steps:
      - name: Configure SSH
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.SSH_PRIVATE_KEY }}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          echo "${{ secrets.SSH_KNOWN_HOSTS }}" > ~/.ssh/known_hosts
          chmod 600 ~/.ssh/known_hosts

      - name: Cleanup Old Jobs
        run: |
          ssh -i ~/.ssh/id_rsa ${{ secrets.TARGET_USER }}@${{ secrets.TARGET_HOST }} '
            echo "Cleaning up old deployment jobs..."
            
            # Keep only the last 3 jobs of each type
            kubectl get jobs -n deployment-automation --sort-by=.metadata.creationTimestamp -o name | head -n -3 | xargs -r kubectl delete -n deployment-automation || true
            
            echo "Cleanup completed"
          '
